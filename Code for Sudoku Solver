	class Sudoku{
		
		int sudoku[9][9];
		int editFrame[9][9];
    public:Sudoku(){
			menu();
		}
		
   private:void menu(){
			
			cout<<"\n";
			cout<<"    Sudoku Solver\n";
			cout<<”\n\n";
	    cout<<"Welcome to Sudoku Solver!\n";
			cout<<"You can input the puzzle into this program.\n\n";
			cout<<”By either:-\n";
			cout<<"\t1.Entering the values manually. (Enter 1)\n";
			cout<<"\t2.Reading a file with values in it. (Enter 2)\n";
      cout<<"\t   --> ";
	    
      int opt;
			cin>>opt;
	

			if(opt==1) readFrameValues();
			else if(opt==2) readFrameValuesFile();
			else{
				while(true){
					cout<<"\nYou seem to have entered an invalid opt. Please, try again.\n";
					cout<<"\t   --> ";
					cin>>opt;
	

					if(opt==1) readFrameValues();
					else if(opt==2) readFrameValuesFile();
					else continue;
	

					break;
				}
			}
	

		}
	
		private:void readFrameValues(){
			cout<<"\nEnter the specified value when prompted.\n";
			cout<<"Enter 0 if cell is empty.\n\n";
			
			int Row, Col;
	

			for(Row=0; Row<9; Row++){
				for(Col=0; Col<9; Col++){
					int entered_value;
	

					cout<<"Enter value for cell["<<Row+1<<"]["<<Col+1<<"] --> ";
					cin>>entered_value;
	

					if(!(entered_value>=0 && entered_value<=9)){
						while(true){ 
							cout<<"The value is not in the range! Try again.\n";
							cout<<"Enter value for cell ["<<Row+1<<"]["<<Col+1<<"] --> ";
							cin>>entered_value;
	

							if(entered_value>=0 && entered_value<=9) break;
						}
					}
	

					sudoku[Row][Col]=entered_value;
	

					if(entered_value==0) editFrame[Row][Col]=0;
					else editFrame[Row][Col]=1;
				}
				cout<<"-------\n";
			}
		}
		

		private:void readFrameValuesFile(){
	

			char filename[30]; 
	

			cout<<"\nEnter the name of the file that contains the Sudoku Puzzle.\n";
			cout<<"\t   --> ";
			cin>>filename;
	

			ifstream sudokuFile; 
			sudokuFile.open(filename,ios::in);
			
			int Row, Col;
	

			for(Row=0; Row<9; Row++){
				for(Col=0; Col<9; Col++){
					int read_value;
			
					sudokuFile>>read_value;
	

					if(!(read_value>=0 && read_value<=9)){
						cout<<"\nValue "<<((Row*9)+Col+1)<<" in "<<filename;
						cout<<" seems to be wrong! Correct the value and try again!\n";
						exit(EXIT_FAILURE);
					}
	

					sudoku[Row][Col]=read_value;
	

					if(sudoku[Row][Col]==0) editFrame[Row][Col]=0;
					else editFrame[Row][Col]=1;
	

					if(sudokuFile.eof()) break;
				}
			}
			
			sudokuFile.close();
		}
		

		public:void setCellValue(int row, int col, int num){
			if(editFrame[row][col]==0) sudoku[row][col]=num;
		}
		
		public:int getCellValue(int row, int col){
			int cellValue=sudoku[row][col];
			return cellValue;
		}
		

		public:int isEditable(int row, int col){
			return (editFrame[row][col]-1)*(-1);
		}

		public:void clearFrame(int row, int col){
			int count=0;
			int Row, Col;
	

			for(Row=row; Row<9; Row++){
				
				if(count==0) Col=col;
				else Col=0;
	

				for(; Col<9; Col++){
					if(editFrame[Row][Col]==0) sudoku[Row][Col]=0;
				}
	

				count++;
	

			}
		}

		public:void displayFrame(){
	

			cout<<"\033[0;36m++=====================================++";
			int Row, Col;
	

			for(Row=0; Row<9; Row++){
				int cell_iator=1;
	

				cout<<"\n\033[0;36m||";
				for(Col=0; Col<9; Col++){
					if(cell_iator==3){
						cout<<"\033[0m "<<sudoku[Row][Col]<<" ";
						cout<<"\033[0;36m||";
						cell_iator=1;
					}
					else{
						cout<<"\033[0m "<<sudoku[Row][Col]<<"  ";
						cell_iator++;	
					}
				}
	

				if(Row%3!=2) cout<<"\n\033[0;36m++-----------++-----------++-----------++";
				else cout<<"\n\033[0;36m++=====================================++";
			}
	

		}
		
	};


	class Possible_cells{
		
		struct node{
			int value;
			struct node* next;
		}; 
		
		typedef struct node* Node;
	

		Node head; 
		Node pos; 


		public:Possible_cells(){
			head=new struct node;
			head->next=NULL;
		}

		public:~Possible_cells(){
			destroy();
		}
		

		public:void append(int number){
			Node temp=new struct node;
	

			temp->value=number;
			temp->next=NULL;
	

			pos=head;
			while(pos!=NULL){
				if(pos->next==NULL){
					pos->next=temp;
					break;
				}
				pos=pos->next;
			}
		}
		

		public:int operator[](int index){
			int count=0;
			pos=head->next;
			
			while(pos!=NULL){
				if(count==index)
					return pos->value;
				pos=pos->next;
				count++;
			}
	

			return -1;
		}
	

		public:void print(){
			pos=head->next;
			while(pos!=NULL){
				cout<<pos->value<<",";
				pos=pos->next;
			}
			cout<<"\b";
		}

		public:int length(){
			pos=head->next;
			int count=0;
	

			while(pos!=NULL){
				count++;
				pos=pos->next;
			}
			
			return count;
		}



		public:void copy(Possible_cells possible_cells){ 
			int oldLength=possible_cells.length();
			int i=0;
			
			pos=head;
			for(i=0; i<oldLength; i++){
				Node temp=new struct node;
	

				temp->next=NULL;
				temp->value=possible_cells[i];
	

				pos->next=temp;
				pos=pos->next;
			}
		}

		private:void destroy(){
			Node temp;
			pos=head;
			while(pos!=NULL){
				temp=pos;
				pos=pos->next;
				delete temp;
			}
		}
	

	};

	class SudokuSolver{
		
		int recursiveCount;
		Sudoku frame; 
	
		public:SudokuSolver(){
			recursiveCount=0;
	

			cout<<"\nCalculating possible_cells...\n";
			cout<<"Backtracking across puzzle....\n";
			cout<<"Validating cells and values...\n\n";
			
			solve();
			cout<<"QED. Your puzzle has been solved!\n\n";
			displayFrame();
	

			cout<<"\n\n";
		}
		

		private:bool valid_cell(int row, int col, int current_value){
			int Row, Col;
	

	
			for(Row=0; Row<9; Row++){
				if(Row!=row){
					int compare_value=frame.getCellValue(Row,col);
					if(compare_value==current_value) return false;
				}
			}
	


			for(Col=0; Col<9; Col++){
				if(Col!=col){
					int compare_value=frame.getCellValue(row,Col);
					if(compare_value==current_value) return false;
				}
			}
	

			
			if(ThreeByThreeGridValid(row,col,current_value)==false) return false;
	

			return true;
		}


		private:bool ThreeByThreeGridValid(int row, int col, int current_value){
			int rowStart=(row/3)*3;
			int rowEnd=(rowStart+2);
	

			int colStart=(col/3)*3;
			int colEnd=(colStart+2);
	

			int Row, Col;
	

			for(Row=rowStart; Row<=rowEnd; Row++){
				for(Col=colStart; Col<=colEnd; Col++){
					if(frame.getCellValue(Row,Col)==current_value) return false;
				}
			}
	

			return true;	
		}

		private:Possible_cells getCellPossible_cells(int row, int col){
			int i=0;
	

			Possible_cells possible_cells;
	

			for(i=1; i<=9; i++){
				if(valid_cell(row,col,i)==true)
					possible_cells.append(i);
			}
	

			return possible_cells;
		}
		

		private:int solve_single_cell(int row, int col){
			
			statsIncrement(); 
	

			if(frame.isEditable(row,col)==true){
	

				Possible_cells possible_cells;
				possible_cells.copy(getCellPossible_cells(row,col));
	

				int posLength=possible_cells.length();
				int posI=0, newRow=row, newCol=col;
	

				for(posI=0; posI<posLength; posI++){
					int possibility=possible_cells[posI];
					frame.setCellValue(row,col,possibility);
					

					if(col<8) newCol=col+1; 
					else if(col==8){
						if(row==8) return 1; 
						newRow=row+1;
						newCol=0;
					}
	

					{
	

						if(solve_single_cell(newRow,newCol)==0){ 
							frame.clearFrame(newRow,newCol);
						}
						else return 1;
	

					} 
	

				} 
	

				return 0;
			} 
			else{
        int newRow=row, newCol=col;
				if(col<8) newCol=col+1;
				else if(col==8){
					if(row==8) return 1;
					newRow=row+1;
					newCol=0;
				}
				return solve_single_cell(newRow,newCol);
			}
		}
	  private:void solve(){
			int success=solve_single_cell(0,0);
		}
		 
    private:void displayFrame(){
			frame.displayFrame();
		}
		
	  private:void statsIncrement(){
			recursiveCount++;
		}

    public:void statsPrint(){
			cout<<"\nThe solve_single_cell() function was recursively called "<<recursiveCount<<" times.\n";
		}
		
	};
	

	int main(){
		SudokuSolver sudokuPuzzle;
		return 0;
	}

